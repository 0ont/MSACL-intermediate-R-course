---
title: 'Lesson 5: Blending data from multiple files and sources'
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readxl)
library(janitor)
```


## Joining Relational Data

The database example for this class has three different data.frames (we use data.frame interchangably with the word tibble, even though we usually mean tibble) : one for batch-level information (calibration R^2^, instrument name); one for sample-level information (sample type, calculated concentration); and one for peak-level information (quant peak area, modification flag). Accessing the relationships across these three sources -- reporting the quant and qual peak area of only the qc samples, for example -- requires the tools of relational data. In the tidyverse, these tools are part of the **dplyr** package and involve three 'families of verbs' called *mutating joins*, *filtering joins*, and *set operations*, which in turn expect a unique key in order to correctly correlate the data. To begin, read in the batch, sample, and peak data from the month of January. For simplicity, we will reduce size of our working examples to only those rows of data associated with one of two batches.

```{r one_batch_three_tables, message=FALSE, eval = FALSE}
jan_batch <- read_csv("data/2017-01-06_b.csv") %>%
  clean_names()
jan_sample <- read_csv("data/2017-01-06_s.csv") %>%
  clean_names()
jan_peak <- read_csv("data/2017-01-06_p.csv") %>%
  clean_names()
select_batches <- jan_batch %>%
  filter(batch_name %in% c("b802253", "b252474"))
select_samples <- jan_sample %>%
  filter(batch_name %in% c("b802253", "b252474"))
select_peaks <- jan_peak %>%
  filter(batch_name %in% c("b802253", "b252474"))
```

Let's first talk about two simple commands in R which bind data, and the pitfalls of relying too heavily upon them.

## Blending Data

### Simple addition of rows and columns

Sometimes, you need data stored across more than one file. For example, managing the QC deviations across twelve separate months of reports. Rather than hold multiple printouts side-by-side to monitor a trend, you can read each file and knit them together either by row, or by column. Working with tidy data means a 'wide' data frame where each column is a specific variable, and each row is a specific measurment. If you know that your data sources have the same format, you can safely combine them with `bind_rows()` (dplyr) or `rbind()` (base) to append the second source of data at the end of the first.

```{r rbind, eval = FALSE}
january <- read_csv("data/2017-01-06_s.csv") %>%
  clean_names()
as.data.frame(january[187195:187200,])
february <- read_csv("data/2017-02-06_s.csv") %>%
  clean_names()
as.data.frame(february[1:5,])
two_months <- bind_rows(january, february)
```

Notice the continuation from the last rows of january to the first rows of february and that the number of rows in the combined data frame two_months is the sum of the first two months of sample-level data.

```{r jan_plus_feb, eval = FALSE}
two_months[187195:187204,]
c(nrow(january), nrow(february), nrow(two_months))
```

Because of how R treats columns, as long as the two files have the same number of columns and the same column names, the `bind_rows` and `rbind` commands will correctly associate the data using the column order from the first variable. And if they aren't the same, you get an error that tells you what is wrong.

```{r bad_rbinds, eval = FALSE}
missing_january <- january[,c(1:9)]
misnamed_january <- january %>%
  dplyr::rename(b_name = batch_name) # more than one package has rename function
```

**Exercise 1:** 

Perform an rbind between February and the two alternative January data frames above. What does the data look like? What error messages do you get?  

```{r, eval = FALSE}

```

```{r}
rbind(missing_january, february)
rbind(misnamed_january, february)
```

**End Exercise**

When adding columns, there is an equivalent base R command to `rbind()` called `cbind()` which will append columns to a data frame, but it is far more risky. The expectation within R that each row of information is correctly organized into a set of columns means this command will not check to make sure the order of values are correct between the two terms. Working to retain the correct association is the purpose of using keys as unique identifiers (see below).

```{r cbind, eval = FALSE}
incomplete_data <- tibble(sample_name="123456",
                          compound_name=c("morphine","hydromorphone","codeine","hydrocodone"),
                          concentration=c(34,35,44,45))
additional_columns <- tibble(expected_concentration=c(20,30,40,40),
                             sampleType="standard")
erroneous_columns <- tibble(expected_concentration=c(40,30,20,40),
                             sampleType="standard")
desired_cbind <- cbind(incomplete_data, additional_columns)
undesired_cbind <- cbind(incomplete_data, erroneous_columns)
```

There is also a dplyr functions with equivalent function: `bind_cols()`. One advantage of the dplyr functions `bind_rows()` and `bind_cols()` is that you can supply more than two arguments via a list and bind many data frames at once.

There are better ways of adding per-column data. Creating a new named vector directly into the existing data frame is straightforward and shown below, but a true merge of two distinct data frames needs more explanation.

```{r add_column_inline, eval = FALSE}
incomplete_data$batch_name <- "batch01"
incomplete_data
```

### Primary and foreign keys

A key is the variable in a data frame -- or combination of variables in a data frame -- that uniquely defines every row. In our data, `batch_name` is present in each data frame but always insufficient to define a specific row. In fact, no single column in our data operates as a key. We can build a key by combinging two (or three) columns.

```{r uniquify, eval = FALSE}
select_batches$keyB <- paste(select_batches$batch_name, select_batches$compound_name, sep=":")
select_samples$keyS <- paste(select_samples$sample_name, select_samples$compound_name, sep=":")
select_peaks$keyP <- paste(select_peaks$sample_name, select_peaks$compound_name, select_peaks$chromatogram_name, sep=":")
```

Doing this creates a **primary key**, which is the unique identifier for that data.frame. A **foreign key** by contrast would uniqely identify an item in another table. The `left_join()` command (described soon) does its job correctly but because the compound names for the internal standards are not identical to the analyte compound names, this command incompletely adds the `select_batches` information to `select_peaks`. The second command completes the population of `select_peaks$keyB` as a foregin key, but only because the row order in `select_peaks` follows a very specific format -- exactly the problem we were worried about when using `cbind()`! There are safer ways of populating this variable which take advantage of set operations (described next).  

```{r select_peaks_foreign_key, eval = FALSE}
select_peaks <- left_join(select_peaks, select_batches)
select_peaks$keyB[is.na(select_peaks$keyB)] <- select_peaks$keyB[!is.na(select_peaks$keyB)] # dangerous!
```

**Exercise 2**

Join the batch and sample data using only the batch-specific key. Since `keyB` is already built for one data frame, creating this variable in `select_samples` is the next step. How would you specify that only this variable which should be used for the join? Notice what that does for all of the variables in the joined data frame.

```{r ex2, eval = FALSE}
select_batches$keyB
# select_samples$keyB <- paste( , ,sep=":")
# exerciseTwo <- left_join( , , )
```

```{r}
select_batches$keyB
select_samples$keyB <- paste(select_samples$batch_name, select_samples$compound_naame, sep=":")
exercise_two <- left_join(select_samples, select_batches, by = "keyB")
```

**End Exercise**

### Set operations *union*, *intersect*, and *setdiff*

These three commands will return a vector which is the unduplicated combination of the two input vectors. `union(A,B)` includes all the values found in both A and B. `intersect(A,B)` returns only those values found in both A and B. `setdiff(A,B)` is order dependent, and returns the values of the first vector which are not also in the second vector.

```{r set_operations}
A <- rep(seq(1, 10), 2)
B <- seq(2, 20, 2)
union(A, B)
intersect(A, B)
setdiff(A, B)
setdiff(B, A)
```

These commands are good for checking matches between two vectors, and we can use them to rebuild the `select_peaks$keyB` foreign key without the risk of incorrect naming. First, let's create the key for the `select_peaks` data using a dplyr alternative to paste called `unite()`. This function takes the data as the first argument, and then will put together specified columns using a separator you specify:

```{r select_peaks_reset}
select_peaks <- jan_peak %>% # all of the above in one tidyverse pipe statement
  filter(batch_name %in% c("b802253","b252474")) %>%
  unite(keyP, sample_name, compound_name, chromatogram_name, sep=":", remove=FALSE)
```

Now let's construct our `select_peaks$keyB` foreign key by creating and then using a new variable called *analyte*, taking advantage of set operations.

```{r better_foreign_key, eval = FALSE}
allNames <- unique(select_peaks$compound_name)
select_peaks$analyte <- NA
for (name in allNames[1:6]) {
  compoundPairIdx <- grep(name, allNames)
  theCompound <- intersect(allNames[compoundPairIdx], name)
  theInternalStandard <- setdiff(allNames[compoundPairIdx], name)
  select_peaks$analyte[select_peaks$compound_name == theInternalStandard] <- theCompound
  select_peaks$analyte[select_peaks$compound_name == theCompound] <- theCompound
}
```

## Mutating join to add columns

Mutating joins operate in much the same way as the set operations, but on data.frames instead of vectors, and with one critical difference: repeated values are retained. We took advantage of this earlier when using the left_join command, so that the `select_batches$keyB` got repeated for both the Quant and the Qual peak entries in `select_peaks`. Having built the `select_batches` primary key, and correctly included it as a foreign key in `select_peaks`, correctly joining them into a single data.frame is straightforward. 
```{r using_primary_and_foreign_keys, eval = FALSE}
select_peaksWide <- left_join(select_peaks,select_batches)
```

There are four kinds of mutating joins, differing in how the rows of the source data.frames are treated. In each case, the matching columns are identified automatically by column name and only one is kept, with row order remaining consistent with the principle (usually the left) source. All non-matching columns are returned, and which rows are returned depends on the type of join. An *inner_join(A,B)* only returns rows from A which have a column match in B. The *full_join(A,B)* returns every row of both A and B, using an NA in those columns which don't have a match. The *left_join(A,B)* returns every row of A, and either the matching value from B or an NA for columns with don't have a match. Finally, the *right_join(A,B)* returns every row of B, keeping the order of B, with either the matching value from columns in A or an NA for columns with no match.

Because these commands can duplicate rows, the potential for breaking things is pretty significant if the key isn't unique. Here are two examples, one where you do -- and one where you do not -- want that duplication:
```{r good_and_bad_duplication, eval = FALSE}
goodDuplication <- inner_join(
  x = select_samples[, c(1:3, 7)],
  y = select_batches[, c(1:6)],
  by = c("batch_name", "compound_name")
)
badDuplication <- inner_join(
  x = select_samples[, c(1:3, 7)],
  y = select_batches[, c(1:6)],
  by = c("compound_name")
)
```

## Filtering join to check the overlap
We created the `select_batches$keyB` explicitly, but it was effectively present already thanks to the *batch_name* and *compound_name* columns. The compound naming scheme in `select_peaks` remains problematic since the internal standard isn't identified in `select_batches` or `select_samples`, but we fixed this using a new column *analyte*. We could have discovered the problem, and then resolved it, using the semi_join and anti_join commands. The *semi_join(A,B)* returns all rows of A where there is a match from B, but keeps only the columns of A, and does not duplicate a row if there are multiple matches. The *anti_join(A,B)* is the inverse, returning all rows from A where there is no match from B. We still want to create the 'analyte' column for clarity, so one approach would be:
```{r filtering_joins, eval = FALSE}
select_batches <- jan_batch %>% # reset, no keyB 
  filter(batch_name %in% c("b802253","b252474"))
select_peaks <- jan_peak %>% # reset, no keyB or keyP 
  filter(batch_name %in% c("b802253","b252474")) %>%
  mutate(analyte=compound_name)

unique(select_peaks$analyte) # notice the similar naming scheme?
select_peaks$analyte <- sub("-.*$", "", select_peaks$analyte) # notice how we used that similarity?

noMatch <- anti_join(select_peaks,select_batches)
noMatch <- anti_join(select_peaks,select_batches,by=c("batch_name","analyte"="compound_name"))

justMatch <- semi_join(select_peaks,select_batches,by=c("batch_name","analyte"="compound_name"))
```

> Exercise 3: Join the batch and peak data  
> Start from the reset data.frames built in the prior code chunk, so the `keyB` and `keyP` variables are not present. Partially complete commands are commented out in the following code chunk.

```{r ex3, eval = FALSE}
# exerciseThree <- left_join( , ,by=c( ) )
```

## Summary
* `rbind` and `cbind` add rows (or columns) to an existing data.frame
* `union`, `intersect`, and `setdiff` return a combination of two vectors
* Relational data merges two data.frames on the common columns, called keys
    + A primary key is a unique identifier for every row in a data.frame (the presence of `keyB` in `select_batches`)
    + A foreign key is a unique identifier for another data.frame (the presence of `keyB` in `select_peaks`)
* `inner_join`, `full_join`, `left_join`, and `right_join` are mutating joins which add columns
* `semi_join` and `anti_join` are filtering joins which check for overlap
