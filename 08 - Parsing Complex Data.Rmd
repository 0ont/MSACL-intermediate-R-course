---
title: 'Lesson 8: Beyond the csv -- parsing xml and json files'
author: "Randall Julian, Adam Zabell"
date: "9/3/2018"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
library(mzR)
```

# Flat and Structured Files
The functions from readr *read_csv*, *read_tsv*, and *read_excel* (discussed in Lesson 5) open so called "Flat" files that are often called 'flat' because they have a simple structure of delimited rows and columns. Some raw instrument data is difficult to describe fully using a simple row and column approach. Several formats have been created to represent more structured data, and some have evolved into standards used across instrument applications. XML is an example of a sophisticated format that has been used to implement many standards and defacto standards. 

## The extensible markup language (xml)
XML is first, simply a text file which follows very specific grammaric rules. On top of this grammar, there is a semantic layer which is application specific. There are  packages for reading generic XML files such as **xml2**. For this lesson, we will focus on a more specific XML file format for representing mass spectrometry raw data. Using XML, several specifications (definition of how the semantic content for mass spectrometry data is represented using the XML grammar)

Reading an xml file requires the **xml2** package (or one like it). Consider a short list of album information, where each entry contains the same number of keys, and those keys are always in the same order.
```{r xml_example, eval = FALSE}
cd <- read_xml("https://www.w3schools.com/xml/cd_catalog.xml")
cd.list <- as_list(cd)
cd.rows <- length(cd.list)
cd.names <- names(cd.list[[1]])
cd.df <- data.frame(
  matrix(
    unlist(cd.list),
    nrow = cd.rows,
    byrow = TRUE,
    dimnames = list(NULL, cd.names)
  ),
  stringsAsFactors = FALSE
)
```

## Solving problems
The most common problem is that numbers, even if they were stored as numbers, can become text strings during conversion to a data.frame. Jumping ahead to the next lesson, the simplest fix will loop on the column of data that should be numeric.
```{r cd_price, eval = FALSE}
cd.df$PRICE %<>% map_dbl(as.numeric) # also invokes a from-and-back-into pipe notation
```

** Exercise 1: Renumbering Redux  
> Will reading the xml into a tibble (instead of a data.frame) solve this number recognition? First, try it. Then, even if it did work, construct a 'standard pipe' mechanism using `%>%` to change both *PRICE* and *YEAR* to double precision numbers.

```{r ex1, eval = FALSE}
# cd.tibble <- as_tibble( )
```

There are many more problems that could happen, ultimately because each entry in the xml or json file is an independent object. There may be an element not present in every entry (e.g. not including a price for a CD), or multiple elements within an element (e.g. two artists for a CD), or the elements may not be retrieved in the same order each time (e.g. all Bob Dylan albums return the artist before the title). All are disasterous; the conversion examples shown here using `matrix` will now be wildly offset.

Most problems should be solved on the query-side of the equation, to confirm the database query was built correctly and that the database is populated as expected. But, since "two artists for one CD" is at least possible and might even be common, the retrieved data could simply be less data.frame friendly than you would like. Unless you're very sure of what the returned data must look like, some basic checks now will avoid exhausting effort later.  

The following code snippet, for example, will go through each list element of `cd.list` and count how many variables are present, and create a key showing their order. Then, at the end, we look for all the *unique* components of our `numberOfElements` and `namesForElements`. If we have more than one, it's a sign we need to correct our query or adjust our expectations.  
```{r troubleshooting, eval = FALSE}
numberOfElements <- c()
namesForElements <- c()
for (l in cd.list) {
  numberOfElements <- c(numberOfElements, length(l))
  namesForElements <- c(namesForElements, paste(names(l), collapse = ":"))
  for (e in l) {
    valuesInElement <- length(e)
    if (valuesInElement != 1) {
      break
    }
  }
  if (valuesInElement != 1) {
    break
  }
}
paste(unique(numberOfElements), unique(namesForElements), sep = " | ")
```

> Exercise 2: Fixing a known misordered data.frame  
> Add this next line to `cd.list` and rerun the troubleshooting code section. What changed in the output from the *paste* command? How would you fix the list so the columns are correct while still using the *matrix* method described in Exercise 1?

```{r ex2, eval = FALSE}
cd.list[[27]] <- list(
  ARTIST = list("Benny Andersson", "Tim Rice", "Bjorn Ulvaeus"),
  TITLE = list("Chess"),
  COUNTRY = list("Sweden"),
  COMPANY = list("RCA Victor"),
  PRICE = list("19.95"),
  YEAR = list("1984")
)
```

> Exercise 3: Preventing a misordered data.frame  
> Propose another way to convert the xml file so it automatically adjusts for inconsistent ordering of the keyword pairs.

```{r ex3, eval = FALSE}
cd <- read_xml("https://www.w3schools.com/xml/cd_catalog.xml")
```

## Summary
* **xml2** for read/writing xml files
* **jsonlite** for read/writing json files
* troubleshoot the returned query result to catch
    + multiple values where a single was expected
    + the same key names are in every entry
    + the key names are always in the same order (or the conversion code robustly adjusts to handle this)
    + numbers stored as strings
    + strings stored as factors
